
R version 3.5.0 (2018-04-23) -- "Joy in Playing"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ## For examples skipped in testing because they are 'random'
> 
> set.seed(1)
> if(.Platform$OS.type == "windows") options(pager = "console")
> 
> pdf("reg-examples-1.pdf", encoding = "ISOLatin1.enc")
> 
> 
> ## base
> example(Cstack_info, run.donttest = TRUE)

Cstck_> ## No test: 
Cstck_> Cstack_info()
      size    current  direction eval_depth 
   7969177      42416          1          9 

Cstck_> ## End(No test)
Cstck_> 
Cstck_> 
> example(DateTimeClasses, run.donttest = TRUE)

DtTmCl> ## No test: 
DtTmCl> (z <- Sys.time())             # the current date, as class "POSIXct"
[1] "2018-04-27 11:33:34 CEST"

DtTmCl> Sys.time() - 3600             # an hour ago
[1] "2018-04-27 10:33:34 CEST"

DtTmCl> as.POSIXlt(Sys.time(), "GMT") # the current time in GMT
[1] "2018-04-27 09:33:34 GMT"

DtTmCl> format(.leap.seconds)         # the leap seconds in your time zone
 [1] "1972-07-01 01:00:00" "1973-01-01 01:00:00" "1974-01-01 01:00:00"
 [4] "1975-01-01 01:00:00" "1976-01-01 01:00:00" "1977-01-01 01:00:00"
 [7] "1978-01-01 01:00:00" "1979-01-01 01:00:00" "1980-01-01 01:00:00"
[10] "1981-07-01 02:00:00" "1982-07-01 02:00:00" "1983-07-01 02:00:00"
[13] "1985-07-01 02:00:00" "1988-01-01 01:00:00" "1990-01-01 01:00:00"
[16] "1991-01-01 01:00:00" "1992-07-01 02:00:00" "1993-07-01 02:00:00"
[19] "1994-07-01 02:00:00" "1996-01-01 01:00:00" "1997-07-01 02:00:00"
[22] "1999-01-01 01:00:00" "2006-01-01 01:00:00" "2009-01-01 01:00:00"
[25] "2012-07-01 02:00:00" "2015-07-01 02:00:00" "2017-01-01 01:00:00"

DtTmCl> print(.leap.seconds, tz = "PST8PDT")  # and in Seattle's
 [1] "1972-06-30 17:00:00 PDT" "1972-12-31 16:00:00 PST"
 [3] "1973-12-31 16:00:00 PST" "1974-12-31 16:00:00 PST"
 [5] "1975-12-31 16:00:00 PST" "1976-12-31 16:00:00 PST"
 [7] "1977-12-31 16:00:00 PST" "1978-12-31 16:00:00 PST"
 [9] "1979-12-31 16:00:00 PST" "1981-06-30 17:00:00 PDT"
[11] "1982-06-30 17:00:00 PDT" "1983-06-30 17:00:00 PDT"
[13] "1985-06-30 17:00:00 PDT" "1987-12-31 16:00:00 PST"
[15] "1989-12-31 16:00:00 PST" "1990-12-31 16:00:00 PST"
[17] "1992-06-30 17:00:00 PDT" "1993-06-30 17:00:00 PDT"
[19] "1994-06-30 17:00:00 PDT" "1995-12-31 16:00:00 PST"
[21] "1997-06-30 17:00:00 PDT" "1998-12-31 16:00:00 PST"
[23] "2005-12-31 16:00:00 PST" "2008-12-31 16:00:00 PST"
[25] "2012-06-30 17:00:00 PDT" "2015-06-30 17:00:00 PDT"
[27] "2016-12-31 16:00:00 PST"

DtTmCl> ## End(No test)
DtTmCl> 
DtTmCl> ## look at *internal* representation of "POSIXlt" :
DtTmCl> leapS <- as.POSIXlt(.leap.seconds)

DtTmCl> names(leapS) ; is.list(leapS)
NULL
[1] TRUE

DtTmCl> ## str() "too smart" -->  need unclass(.):
DtTmCl> utils::str(unclass(leapS), vec.len = 7)
List of 11
 $ sec   : num [1:27] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
 $ min   : int [1:27] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
 $ hour  : int [1:27] 1 1 1 1 1 1 1 1 1 2 2 2 2 1 1 1 2 2 ...
 $ mday  : int [1:27] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
 $ mon   : int [1:27] 6 0 0 0 0 0 0 0 0 6 6 6 6 0 0 0 6 6 ...
 $ year  : int [1:27] 72 73 74 75 76 77 78 79 80 81 82 83 85 88 90 91 92 93 ...
 $ wday  : int [1:27] 6 1 2 3 4 6 0 1 2 3 4 5 1 5 1 2 3 4 ...
 $ yday  : int [1:27] 182 0 0 0 0 0 0 0 0 181 181 181 181 0 0 0 182 181 ...
 $ isdst : int [1:27] 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 1 1 ...
 $ zone  : chr [1:27] "CET" "CET" "CET" "CET" "CET" "CET" "CET" ...
 $ gmtoff: int [1:27] 3600 3600 3600 3600 3600 3600 3600 3600 3600 7200 7200 7200 7200 3600 3600 3600 7200 7200 ...
 - attr(*, "tzone")= chr [1:3] "" "CET" "CEST"

DtTmCl> ## Extracting *single* components of POSIXlt objects:
DtTmCl> leapS[1 : 5, "year"]
[1] 72 73 74 75 76

DtTmCl> ##  length(.) <- n   now works for "POSIXct" and "POSIXlt" :
DtTmCl> for(lpS in list(.leap.seconds, leapS)) {
DtTmCl+     ls <- lpS; length(ls) <- 12
DtTmCl+     l2 <- lpS; length(l2) <- 5 + length(lpS)
DtTmCl+     stopifnot(exprs = {
DtTmCl+       ## length(.) <- * is compatible to subsetting/indexing:
DtTmCl+       identical(ls, lpS[seq_along(ls)])
DtTmCl+       identical(l2, lpS[seq_along(l2)])
DtTmCl+       ## has filled with NA's
DtTmCl+       is.na(l2[(length(lpS)+1):length(l2)])
DtTmCl+     })
DtTmCl+ }
> example(Dates, run.donttest = TRUE)

Dates> ## No test: 
Dates> (today <- Sys.Date())
[1] "2018-04-27"

Dates> format(today, "%d %b %Y")  # with month as a word
[1] "27 Apr 2018"

Dates> (tenweeks <- seq(today, length.out=10, by="1 week")) # next ten weeks
 [1] "2018-04-27" "2018-05-04" "2018-05-11" "2018-05-18" "2018-05-25"
 [6] "2018-06-01" "2018-06-08" "2018-06-15" "2018-06-22" "2018-06-29"

Dates> weekdays(today)
[1] "Friday"

Dates> months(tenweeks)
 [1] "April" "May"   "May"   "May"   "May"   "June"  "June"  "June"  "June" 
[10] "June" 

Dates> (Dls <- as.Date(.leap.seconds))
 [1] "1972-07-01" "1973-01-01" "1974-01-01" "1975-01-01" "1976-01-01"
 [6] "1977-01-01" "1978-01-01" "1979-01-01" "1980-01-01" "1981-07-01"
[11] "1982-07-01" "1983-07-01" "1985-07-01" "1988-01-01" "1990-01-01"
[16] "1991-01-01" "1992-07-01" "1993-07-01" "1994-07-01" "1996-01-01"
[21] "1997-07-01" "1999-01-01" "2006-01-01" "2009-01-01" "2012-07-01"
[26] "2015-07-01" "2017-01-01"

Dates> ##  length(<Date>) <- n   now works
Dates> ls <- Dls; length(ls) <- 12

Dates> l2 <- Dls; length(l2) <- 5 + length(Dls)

Dates> stopifnot(exprs = {
Dates+   ## length(.) <- * is compatible to subsetting/indexing:
Dates+   identical(ls, Dls[seq_along(ls)])
Dates+   identical(l2, Dls[seq_along(l2)])
Dates+   ## has filled with NA's
Dates+   is.na(l2[(length(Dls)+1):length(l2)])
Dates+ })

Dates> ## End(No test)
Dates> 
Dates> 
> example(Ops.Date, run.donttest = TRUE)

Ops.Dt> ## No test: 
Ops.Dt> (z <- Sys.Date())
[1] "2018-04-27"

Ops.Dt> z + 10
[1] "2018-05-07"

Ops.Dt> z < c("2009-06-01", "2010-01-01", "2015-01-01")
[1] FALSE FALSE FALSE

Ops.Dt> ## End(No test)
Ops.Dt> 
Ops.Dt> 
> example(Random, run.donttest = TRUE)

Random> ## No test: 
Random> require(stats)

Random> ## the default random seed is 626 integers, so only print a few
Random> runif(1); .Random.seed[1:6]; runif(1); .Random.seed[1:6]
[1] 0.2655087
[1]         403           1  1654269195 -1877109783  -961256264  1403523942
[1] 0.3721239
[1]         403           2  1654269195 -1877109783  -961256264  1403523942

Random> ## If there is no seed, a "random" new one is created:
Random> rm(.Random.seed); runif(1); .Random.seed[1:6]
[1] 0.08925347
[1]        403          1  561997977  272611624 1188716502 1672580177

Random> ok <- RNGkind()

Random> RNGkind("Wich")  # (partial string matching on 'kind')

Random> ## This shows how 'runif(.)' works for Wichmann-Hill,
Random> ## using only R functions:
Random> 
Random> p.WH <- c(30269, 30307, 30323)

Random> a.WH <- c(  171,   172,   170)

Random> next.WHseed <- function(i.seed = .Random.seed[-1])
Random+   { (a.WH * i.seed) %% p.WH }

Random> my.runif1 <- function(i.seed = .Random.seed)
Random+   { ns <- next.WHseed(i.seed[-1]); sum(ns / p.WH) %% 1 }

Random> rs <- .Random.seed

Random> (WHs <- next.WHseed(rs[-1]))
[1] 14133  1700 29452

Random> u <- runif(1)

Random> stopifnot(
Random+  next.WHseed(rs[-1]) == .Random.seed[-1],
Random+  all.equal(u, my.runif1(rs))
Random+ )

Random> ## ----
Random> .Random.seed
[1]   400 14133  1700 29452

Random> RNGkind("Super") # matches  "Super-Duper"

Random> RNGkind()
[1] "Super-Duper" "Inversion"  

Random> .Random.seed # new, corresponding to  Super-Duper
[1]         402 -1507997456  1375606833

Random> ## Reset:
Random> RNGkind(ok[1])

Random> ## ----
Random> sum(duplicated(runif(1e6))) # around 110 for default generator
[1] 126

Random> ## and we would expect about almost sure duplicates beyond about
Random> qbirthday(1 - 1e-6, classes = 2e9) # 235,000
[1] 235075

Random> ## End(No test)
Random> 
Random> 
> example(Sys.getpid, run.donttest = TRUE)

Sys.gt> ## No test: 
Sys.gt> Sys.getpid()
[1] 13346

Sys.gt> ## Show files opened from this R process
Sys.gt> if(.Platform$OS.type == "unix") ## on Unix-alikes such Linux, macOS, FreeBSD:
Sys.gt+    system(paste("lsof -p", Sys.getpid()))
COMMAND   PID    USER   FD   TYPE             DEVICE SIZE/OFF     NODE NAME
R       13346 mmigdal  cwd    DIR               8,19     4096 14159335 /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/tests
R       13346 mmigdal  rtd    DIR               8,19     4096        2 /
R       13346 mmigdal  txt    REG               8,19 13294784 16391106 /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/bin/exec/R
R       13346 mmigdal  mem    REG               8,19   359960 17045293 /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/library/tools/libs/tools.so
R       13346 mmigdal  mem    REG               8,19  5066400 16257855 /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/lib/libRlapack.so
R       13346 mmigdal  mem    REG               8,19  2864344 17045697 /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/library/stats/libs/stats.so
R       13346 mmigdal  mem    REG               8,19  1360744 17045551 /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/library/graphics/libs/graphics.so
R       13346 mmigdal  mem    REG               8,19   231992 17045345 /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/library/utils/libs/utils.so
R       13346 mmigdal  mem    REG               8,19   788704 17045501 /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/library/grDevices/libs/grDevices.so
R       13346 mmigdal  mem    REG               8,19   166240 17045734 /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/library/methods/libs/methods.so
R       13346 mmigdal  mem    REG               8,19   178632   268504 /usr/lib/libtinfo.so.6.0
R       13346 mmigdal  mem    REG               8,19 11592384   265799 /usr/lib/libstdc++.so.6.0.24
R       13346 mmigdal  mem    REG               8,19 26903192   312132 /usr/lib/libicudata.so.60.2
R       13346 mmigdal  mem    REG               8,19   226936   268506 /usr/lib/libncursesw.so.6.0
R       13346 mmigdal  mem    REG               8,19   760728   313483 /usr/lib/libgcc_s.so.1
R       13346 mmigdal  mem    REG               8,19  2065784   264359 /usr/lib/libc-2.26.so
R       13346 mmigdal  mem    REG               8,19   145336   264380 /usr/lib/libpthread-2.26.so
R       13346 mmigdal  mem    REG               8,19  1111536   265831 /usr/lib/libgomp.so.1.0.0
R       13346 mmigdal  mem    REG               8,19  2762824   280409 /usr/lib/libicui18n.so.60.2
R       13346 mmigdal  mem    REG               8,19  1799960   280407 /usr/lib/libicuuc.so.60.2
R       13346 mmigdal  mem    REG               8,19    14160   264292 /usr/lib/libdl-2.26.so
R       13346 mmigdal  mem    REG               8,19    30920   264254 /usr/lib/librt-2.26.so
R       13346 mmigdal  mem    REG               8,19    92056   272978 /usr/lib/libz.so.1.2.11
R       13346 mmigdal  mem    REG               8,19    66960   268730 /usr/lib/libbz2.so.1.0.6
R       13346 mmigdal  mem    REG               8,19   154344   272651 /usr/lib/liblzma.so.5.2.3
R       13346 mmigdal  mem    REG               8,19   469216   275513 /usr/lib/libpcre.so.1.2.9
R       13346 mmigdal  mem    REG               8,19   538664   313687 /usr/lib/libpcre2-8.so.0.6.0
R       13346 mmigdal  mem    REG               8,19   363064   268528 /usr/lib/libreadline.so.7.0
R       13346 mmigdal  mem    REG               8,19   983040   265822 /usr/lib/libquadmath.so.0.0.0
R       13346 mmigdal  mem    REG               8,19  1358184   264286 /usr/lib/libm-2.26.so
R       13346 mmigdal  mem    REG               8,19  7466408   313410 /usr/lib/libgfortran.so.4.0.0
R       13346 mmigdal  mem    REG               8,19   434056 16257854 /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/lib/libRblas.so
R       13346 mmigdal  mem    REG               8,19   176640   264360 /usr/lib/ld-2.26.so
R       13346 mmigdal    0r   REG               8,19     3091 14159403 /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/tests/reg-examples1.R
R       13346 mmigdal    1w   REG               8,19     8600 14159488 /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/tests/reg-examples1.Rout.fail
R       13346 mmigdal    2w   REG               8,19     8600 14159488 /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/tests/reg-examples1.Rout.fail
R       13346 mmigdal    3w   REG               8,19        0 14159489 /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/tests/reg-examples-1.pdf
R       13346 mmigdal   26u  unix 0x000000006c88d69b      0t0  2652935 type=STREAM
R       13346 mmigdal   27u  unix 0x00000000e9a407ff      0t0  2652936 type=STREAM
R       13346 mmigdal   37u  unix 0x00000000d9089a14      0t0  2657574 type=STREAM
R       13346 mmigdal   38u  unix 0x00000000e513f639      0t0  2657575 type=STREAM

Sys.gt> ## End(No test)
Sys.gt> 
Sys.gt> 
> example(Sys.sleep, run.donttest = TRUE)

Sys.sl> ## No test: 
Sys.sl> testit <- function(x)
Sys.sl+ {
Sys.sl+     p1 <- proc.time()
Sys.sl+     Sys.sleep(x)
Sys.sl+     proc.time() - p1 # The cpu usage should be negligible
Sys.sl+ }

Sys.sl> testit(3.7)
   user  system elapsed 
  0.001   0.000   3.704 

Sys.sl> ## End(No test)
Sys.sl> 
Sys.sl> 
> example(Sys.time, run.donttest = TRUE)

Sys.tm> ## No test: 
Sys.tm> Sys.time()
[1] "2018-04-27 11:33:38 CEST"

Sys.tm> ## print with possibly greater accuracy:
Sys.tm> op <- options(digits.secs = 6)

Sys.tm> Sys.time()
[1] "2018-04-27 11:33:38.295178 CEST"

Sys.tm> options(op)

Sys.tm> ## locale-specific version of date()
Sys.tm> format(Sys.time(), "%a %b %d %X %Y")
[1] "Fri Apr 27 11:33:38 2018"

Sys.tm> Sys.Date()
[1] "2018-04-27"

Sys.tm> ## End(No test)
Sys.tm> 
Sys.tm> 
> example(as.POSIXlt, run.donttest = TRUE)

a.POSI> ## No test: 
a.POSI> (z <- Sys.time())             # the current datetime, as class "POSIXct"
[1] "2018-04-27 11:33:38 CEST"

a.POSI> unclass(z)                    # a large integer
[1] 1524821618

a.POSI> floor(unclass(z)/86400)       # the number of days since 1970-01-01 (UTC)
[1] 17648

a.POSI> (now <- as.POSIXlt(Sys.time())) # the current datetime, as class "POSIXlt"
[1] "2018-04-27 11:33:38 CEST"

a.POSI> unlist(unclass(now))          # a list shown as a named vector
               sec                min               hour               mday 
"38.3208708763123"               "33"               "11"               "27" 
               mon               year               wday               yday 
               "3"              "118"                "5"              "116" 
             isdst               zone             gmtoff 
               "1"             "CEST"             "7200" 

a.POSI> now$year + 1900               # see ?DateTimeClasses
[1] 2018

a.POSI> months(now); weekdays(now)    # see ?months
[1] "April"
[1] "Friday"

a.POSI> ## suppose we have a time in seconds since 1960-01-01 00:00:00 GMT
a.POSI> ## (the origin used by SAS)
a.POSI> z <- 1472562988

a.POSI> # ways to convert this
a.POSI> as.POSIXct(z, origin = "1960-01-01")                # local
[1] "2006-08-30 15:16:28 CEST"

a.POSI> as.POSIXct(z, origin = "1960-01-01", tz = "GMT")    # in UTC
[1] "2006-08-30 13:16:28 GMT"

a.POSI> ## SPSS dates (R-help 2006-02-16)
a.POSI> z <- c(10485849600, 10477641600, 10561104000, 10562745600)

a.POSI> as.Date(as.POSIXct(z, origin = "1582-10-14", tz = "GMT"))
[1] "1915-01-26" "1914-10-23" "1917-06-15" "1917-07-04"

a.POSI> ## Stata date-times: milliseconds since 1960-01-01 00:00:00 GMT
a.POSI> ## format %tc excludes leap-seconds, assumed here
a.POSI> ## For format %tC including leap seconds, see foreign::read.dta()
a.POSI> z <- 1579598122120

a.POSI> op <- options(digits.secs = 3)

a.POSI> # avoid rounding down: milliseconds are not exactly representable
a.POSI> as.POSIXct((z+0.1)/1000, origin = "1960-01-01")
[1] "2010-01-20 10:15:22.120 CET"

a.POSI> options(op)

a.POSI> ## Matlab 'serial day number' (days and fractional days)
a.POSI> z <- 7.343736909722223e5 # 2010-08-23 16:35:00

a.POSI> as.POSIXct((z - 719529)*86400, origin = "1970-01-01", tz = "UTC")
[1] "2010-08-23 16:35:00 UTC"

a.POSI> as.POSIXlt(Sys.time(), "GMT") # the current time in UTC
[1] "2018-04-27 09:33:38 GMT"

a.POSI> ## End(No test)
a.POSI> ## No test: 
a.POSI> ## These may not be correct names on your system
a.POSI> as.POSIXlt(Sys.time(), "America/New_York")  # in New York
[1] "2018-04-27 05:33:38 EDT"

a.POSI> as.POSIXlt(Sys.time(), "EST5EDT")           # alternative.
[1] "2018-04-27 05:33:38 EDT"

a.POSI> as.POSIXlt(Sys.time(), "EST" )   # somewhere in Eastern Canada
[1] "2018-04-27 04:33:38 EST"

a.POSI> as.POSIXlt(Sys.time(), "HST")    # in Hawaii
[1] "2018-04-26 23:33:38 HST"

a.POSI> as.POSIXlt(Sys.time(), "Australia/Darwin")
[1] "2018-04-27 19:03:38 ACST"

a.POSI> ## End(No test)
a.POSI> 
a.POSI> 
> example(difftime, run.donttest = TRUE)

difftm> ## No test: 
difftm> (z <- Sys.time() - 3600)
[1] "2018-04-27 10:33:38 CEST"

difftm> Sys.time() - z                # just over 3600 seconds.
Time difference of 1 hours

difftm> ## time interval between release days of R 1.2.2 and 1.2.3.
difftm> ISOdate(2001, 4, 26) - ISOdate(2001, 2, 26)
Time difference of 59 days

difftm> as.difftime(c("0:3:20", "11:23:15"))
Time differences in mins
[1]   3.333333 683.250000

difftm> as.difftime(c("3:20", "23:15", "2:"), format = "%H:%M") # 3rd gives NA
Time differences in hours
[1]  3.333333 23.250000        NA

difftm> (z <- as.difftime(c(0,30,60), units = "mins"))
Time differences in mins
[1]  0 30 60

difftm> as.numeric(z, units = "secs")
[1]    0 1800 3600

difftm> as.numeric(z, units = "hours")
[1] 0.0 0.5 1.0

difftm> format(z)
[1] " 0 mins" "30 mins" "60 mins"

difftm> ## End(No test)
difftm> 
difftm> 
> example(format.Date, run.donttest = TRUE)

frmt.D> ## No test: 
frmt.D> ## locale-specific version of the date
frmt.D> format(Sys.Date(), "%a %b %d")
[1] "Fri Apr 27"

frmt.D> ## End(No test)
frmt.D> 
frmt.D> ## read in date info in format 'ddmmmyyyy'
frmt.D> ## This will give NA(s) in some locales; setting the C locale
frmt.D> ## as in the commented lines will overcome this on most systems.
frmt.D> ## lct <- Sys.getlocale("LC_TIME"); Sys.setlocale("LC_TIME", "C")
frmt.D> x <- c("1jan1960", "2jan1960", "31mar1960", "30jul1960")

frmt.D> z <- as.Date(x, "%d%b%Y")

frmt.D> ## Sys.setlocale("LC_TIME", lct)
frmt.D> z
[1] "1960-01-01" "1960-01-02" "1960-03-31" "1960-07-30"

frmt.D> ## read in date/time info in format 'm/d/y'
frmt.D> dates <- c("02/27/92", "02/27/92", "01/14/92", "02/28/92", "02/01/92")

frmt.D> as.Date(dates, "%m/%d/%y")
[1] "1992-02-27" "1992-02-27" "1992-01-14" "1992-02-28" "1992-02-01"

frmt.D> ## date given as number of days since 1900-01-01 (a date in 1989)
frmt.D> as.Date(32768, origin = "1900-01-01")
[1] "1989-09-19"

frmt.D> ## Excel is said to use 1900-01-01 as day 1 (Windows default) or
frmt.D> ## 1904-01-01 as day 0 (Mac default), but this is complicated by Excel
frmt.D> ## incorrectly treating 1900 as a leap year.
frmt.D> ## So for dates (post-1901) from Windows Excel
frmt.D> as.Date(35981, origin = "1899-12-30") # 1998-07-05
[1] "1998-07-05"

frmt.D> ## and Mac Excel
frmt.D> as.Date(34519, origin = "1904-01-01") # 1998-07-05
[1] "1998-07-05"

frmt.D> ## (these values come from http://support.microsoft.com/kb/214330)
frmt.D> 
frmt.D> ## Experiment shows that Matlab's origin is 719529 days before ours,
frmt.D> ## (it takes the non-existent 0000-01-01 as day 1)
frmt.D> ## so Matlab day 734373 can be imported as
frmt.D> as.Date(734373, origin = "1970-01-01") - 719529 # 2010-08-23
[1] "2010-08-23"

frmt.D> ## (value from
frmt.D> ## http://www.mathworks.de/de/help/matlab/matlab_prog/represent-date-and-times-in-MATLAB.html)
frmt.D> 
frmt.D> ## Time zone effect
frmt.D> z <- ISOdate(2010, 04, 13, c(0,12)) # midnight and midday UTC

frmt.D> as.Date(z) # in UTC
[1] "2010-04-13" "2010-04-13"

frmt.D> ## No test: 
frmt.D> ## these time zone names are common
frmt.D> as.Date(z, tz = "NZ")
[1] "2010-04-13" "2010-04-14"

frmt.D> as.Date(z, tz = "HST") # Hawaii
[1] "2010-04-12" "2010-04-13"

frmt.D> ## End(No test)
frmt.D> 
frmt.D> 
frmt.D> 
> example(Reduce, run.donttest = TRUE) # funprog.Rd

Reduce> ## A general-purpose adder:
Reduce> add <- function(x) Reduce("+", x)

Reduce> add(list(1, 2, 3))
[1] 6

Reduce> ## Like sum(), but can also used for adding matrices etc., as it will
Reduce> ## use the appropriate '+' method in each reduction step.
Reduce> ## More generally, many generics meant to work on arbitrarily many
Reduce> ## arguments can be defined via reduction:
Reduce> FOO <- function(...) Reduce(FOO2, list(...))

Reduce> FOO2 <- function(x, y) UseMethod("FOO2")

Reduce> ## FOO() methods can then be provided via FOO2() methods.
Reduce> 
Reduce> ## A general-purpose cumulative adder:
Reduce> cadd <- function(x) Reduce("+", x, accumulate = TRUE)

Reduce> cadd(seq_len(7))
[1]  1  3  6 10 15 21 28

Reduce> ## A simple function to compute continued fractions:
Reduce> cfrac <- function(x) Reduce(function(u, v) u + 1 / v, x, right = TRUE)

Reduce> ## Continued fraction approximation for pi:
Reduce> cfrac(c(3, 7, 15, 1, 292))
[1] 3.141593

Reduce> ## Continued fraction approximation for Euler's number (e):
Reduce> cfrac(c(2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8))
[1] 2.718282

Reduce> ## Iterative function application:
Reduce> Funcall <- function(f, ...) f(...)

Reduce> ## Compute log(exp(acos(cos(0))))
Reduce> Reduce(Funcall, list(log, exp, acos, cos), 0, right = TRUE)
[1] 0

Reduce> ## n-fold iterate of a function, functional style:
Reduce> Iterate <- function(f, n = 1)
Reduce+     function(x) Reduce(Funcall, rep.int(list(f), n), x, right = TRUE)

Reduce> ## Continued fraction approximation to the golden ratio:
Reduce> Iterate(function(x) 1 + 1 / x, 30)(1)
[1] 1.618034

Reduce> ## which is the same as
Reduce> cfrac(rep.int(1, 31))
[1] 1.618034

Reduce> ## Computing square root approximations for x as fixed points of the
Reduce> ## function t |-> (t + x / t) / 2, as a function of the initial value:
Reduce> asqrt <- function(x, n) Iterate(function(t) (t + x / t) / 2, n)

Reduce> asqrt(2, 30)(10) # Starting from a positive value => +sqrt(2)
[1] 1.414214

Reduce> asqrt(2, 30)(-1) # Starting from a negative value => -sqrt(2)
[1] -1.414214

Reduce> ## A list of all functions in the base environment:
Reduce> funs <- Filter(is.function, sapply(ls(baseenv()), get, baseenv()))

Reduce> ## Functions in base with more than 10 arguments:
Reduce> names(Filter(function(f) length(formals(f)) > 10, funs))
[1] "format.default"   "formatC"          "merge.data.frame" "prettyNum"       
[5] "scan"             "source"           "system2"         

Reduce> ## Number of functions in base with a '...' argument:
Reduce> length(Filter(function(f)
Reduce+               any(names(formals(f)) %in% "..."),
Reduce+               funs))
[1] 413

Reduce> ## No test: 
Reduce> ## Find all objects in the base environment which are *not* functions:
Reduce> Filter(Negate(is.function),  sapply(ls(baseenv()), get, baseenv()))
$F
[1] FALSE

$LETTERS
 [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S"
[20] "T" "U" "V" "W" "X" "Y" "Z"

$R.version
               _                           
platform       x86_64-pc-linux-gnu         
arch           x86_64                      
os             linux-gnu                   
system         x86_64, linux-gnu           
status                                     
major          3                           
minor          5.0                         
year           2018                        
month          04                          
day            23                          
svn rev        74626                       
language       R                           
version.string R version 3.5.0 (2018-04-23)
nickname       Joy in Playing              

$R.version.string
[1] "R version 3.5.0 (2018-04-23)"

$T
[1] TRUE

$letters
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"

$month.abb
 [1] "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"

$month.name
 [1] "January"   "February"  "March"     "April"     "May"       "June"     
 [7] "July"      "August"    "September" "October"   "November"  "December" 

$pi
[1] 3.141593

$version
               _                           
platform       x86_64-pc-linux-gnu         
arch           x86_64                      
os             linux-gnu                   
system         x86_64, linux-gnu           
status                                     
major          3                           
minor          5.0                         
year           2018                        
month          04                          
day            23                          
svn rev        74626                       
language       R                           
version.string R version 3.5.0 (2018-04-23)
nickname       Joy in Playing              


Reduce> ## End(No test)
Reduce> 
Reduce> 
> example(gc, run.donttest = TRUE)

gc> ## No test: 
gc> gc() #- do it now
          used (Mb) gc trigger (Mb) max used (Mb)
Ncells  486133   26    1075207 57.5   627488 33.6
Vcells 1039296    8    8388608 64.0  6232957 47.6

gc> gcinfo(TRUE) #-- in the future, show when R does it
[1] FALSE

gc> x <- integer(100000); for(i in 1:18) x <- c(x, i)

gc> gcinfo(verbose = FALSE) #-- don't show it anymore
[1] TRUE

gc> gc(TRUE)
Garbage collection 8 = 5+0+3 (level 2) ... 
26.0 Mbytes of cons cells used (45%)
8.4 Mbytes of vectors used (13%)
          used (Mb) gc trigger (Mb) max used (Mb)
Ncells  486121 26.0    1075207 57.5   627488 33.6
Vcells 1089262  8.4    8388608 64.0  6232957 47.6

gc> gc(reset = TRUE)
          used (Mb) gc trigger (Mb) max used (Mb)
Ncells  486129 26.0    1075207 57.5   486129 26.0
Vcells 1089294  8.4    8388608 64.0  1089294  8.4

gc> ## End(No test)
gc> 
gc> 
> example(memory.profile, run.donttest = TRUE)

mmry.p> ## No test: 
mmry.p> memory.profile()
       NULL      symbol    pairlist     closure environment     promise 
          1        8685      226342        4187        1064        6819 
   language     special     builtin        char     logical     integer 
      71025          45         680       11069        8211       46683 
     double     complex   character         ...         any        list 
       3302          22       54862           0           0       21406 
 expression    bytecode externalptr     weakref         raw          S4 
          3       18628        1367         400         410         871 

mmry.p> ## End(No test)
mmry.p> 
mmry.p> 
> paste("Today is", date()) # from paste.Rd
[1] "Today is Fri Apr 27 11:33:38 2018"
> trunc(Sys.time(), "day") # from round.POSIXt.Rd
[1] "2018-04-27 CEST"
> example(srcref, run.donttest = TRUE)

srcref> ## No test: 
srcref>  # has timestamp
srcref> src <- srcfile(system.file("DESCRIPTION", package = "base"))

srcref> summary(src)
/home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/library/base/DESCRIPTION 
Timestamp: 2018-04-27 11:25:52 CEST
Encoding: "native.enc"

srcref> getSrcLines(src, 1, 4)
[1] "Package: base"             "Version: 3.5.0"           
[3] "Priority: base"            "Title: The R Base Package"

srcref> ref <- srcref(src, c(1, 1, 2, 1000))

srcref> ref
Package: base
Version: 3.5.0

srcref> print(ref, useSource = FALSE)
<srcref: file "/home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/library/base/DESCRIPTION" chars 1:1 to 2:1000>

srcref> ## End(No test)
srcref> 
srcref> 
> example(strptime, run.donttest = TRUE)

strptm> ## No test: 
strptm> ## locale-specific version of date()
strptm> format(Sys.time(), "%a %b %d %X %Y %Z")
[1] "Fri Apr 27 11:33:38 2018 CEST"

strptm> ## time to sub-second accuracy (if supported by the OS)
strptm> format(Sys.time(), "%H:%M:%OS3")
[1] "11:33:38.769"

strptm> ## read in date info in format 'ddmmmyyyy'
strptm> ## This will give NA(s) in some locales; setting the C locale
strptm> ## as in the commented lines will overcome this on most systems.
strptm> ## lct <- Sys.getlocale("LC_TIME"); Sys.setlocale("LC_TIME", "C")
strptm> x <- c("1jan1960", "2jan1960", "31mar1960", "30jul1960")

strptm> z <- strptime(x, "%d%b%Y")

strptm> ## Sys.setlocale("LC_TIME", lct)
strptm> z
[1] "1960-01-01 CET"  "1960-01-02 CET"  "1960-03-31 CET"  "1960-07-30 CEST"

strptm> ## read in date/time info in format 'm/d/y h:m:s'
strptm> dates <- c("02/27/92", "02/27/92", "01/14/92", "02/28/92", "02/01/92")

strptm> times <- c("23:03:20", "22:29:56", "01:03:30", "18:21:03", "16:56:26")

strptm> x <- paste(dates, times)

strptm> strptime(x, "%m/%d/%y %H:%M:%S")
[1] "1992-02-27 23:03:20 CET" "1992-02-27 22:29:56 CET"
[3] "1992-01-14 01:03:30 CET" "1992-02-28 18:21:03 CET"
[5] "1992-02-01 16:56:26 CET"

strptm> ## time with fractional seconds
strptm> z <- strptime("20/2/06 11:16:16.683", "%d/%m/%y %H:%M:%OS")

strptm> z # prints without fractional seconds
[1] "2006-02-20 11:16:16 CET"

strptm> op <- options(digits.secs = 3)

strptm> z
[1] "2006-02-20 11:16:16.683 CET"

strptm> options(op)

strptm> ## time zones name are not portable, but 'EST5EDT' comes pretty close.
strptm> (x <- strptime(c("2006-01-08 10:07:52", "2006-08-07 19:33:02"),
strptm+                "%Y-%m-%d %H:%M:%S", tz = "EST5EDT"))
[1] "2006-01-08 10:07:52 EST" "2006-08-07 19:33:02 EDT"

strptm> attr(x, "tzone")
[1] "EST5EDT" "EST"     "EDT"    

strptm> ## An RFC 822 header (Eastern Canada, during DST)
strptm> strptime("Tue, 23 Mar 2010 14:36:38 -0400",  "%a, %d %b %Y %H:%M:%S %z")
[1] "2010-03-23 19:36:38"

strptm> ## Make sure you know what the abbreviated names are for you if you wish
strptm> ## to use them for input (they are matched case-insensitively):
strptm> format(seq.Date(as.Date('1978-01-01'), by = 'day', len = 7), "%a")
[1] "Sun" "Mon" "Tue" "Wed" "Thu" "Fri" "Sat"

strptm> format(seq.Date(as.Date('2000-01-01'), by = 'month', len = 12), "%b")
 [1] "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"

strptm> ## End(No test)
strptm> 
strptm> 
> example(sys.parent, run.donttest = TRUE)

sys.pr> ## No test: 
sys.pr> require(utils)

sys.pr> ## Note: the first two examples will give different results
sys.pr> ## if run by example().
sys.pr> ff <- function(x) gg(x)

sys.pr> gg <- function(y) sys.status()

sys.pr> str(ff(1))
List of 3
 $ sys.calls  :Dotted pair list of 9
  ..$ : language example(sys.parent, run.donttest = TRUE)
  ..$ : language source(tf, local, echo = echo, prompt.echo = paste0(prompt.prefix, getOption("prompt")),      continue.echo = pas| __truncated__ ...
  ..$ : language withVisible(eval(ei, envir))
  ..$ : language eval(ei, envir)
  ..$ : language eval(ei, envir)
  ..$ : language str(ff(1))
  .. ..- attr(*, "srcref")= 'srcref' int [1:8] 15 1 15 10 1 10 15 15
  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55c12cf7ed88> 
  ..$ : language ff(1)
  ..$ : language gg(x)
  .. ..- attr(*, "srcref")= 'srcref' int [1:8] 13 7 13 23 7 23 13 13
  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55c12cf7ed88> 
  ..$ : language sys.status()
  .. ..- attr(*, "srcref")= 'srcref' int [1:8] 14 7 14 30 7 30 14 14
  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55c12cf7ed88> 
 $ sys.parents: int [1:9] 0 1 2 2 4 0 0 7 8
 $ sys.frames :Dotted pair list of 9
  ..$ :<environment: 0x55c12cb8ffd0> 
  ..$ :<environment: 0x55c12e483248> 
  ..$ :<environment: 0x55c12da2f9a8> 
  ..$ :<environment: 0x55c12da2fb68> 
  ..$ :<environment: R_GlobalEnv> 
  ..$ :<environment: 0x55c12da2fe40> 
  ..$ :<environment: 0x55c12da30000> 
  ..$ :<environment: 0x55c12da30150> 
  ..$ :<environment: 0x55c12da301f8> 

sys.pr> gg <- function(y) {
sys.pr+     ggg <- function() {
sys.pr+         cat("current frame is", sys.nframe(), "\n")
sys.pr+         cat("parents are", sys.parents(), "\n")
sys.pr+         print(sys.function(0)) # ggg
sys.pr+         print(sys.function(2)) # gg
sys.pr+     }
sys.pr+     if(y > 0) gg(y-1) else ggg()
sys.pr+ }

sys.pr> gg(3)
current frame is 10 
parents are 0 1 2 2 4 0 6 7 8 9 
function() {
        cat("current frame is", sys.nframe(), "\n")
        cat("parents are", sys.parents(), "\n")
        print(sys.function(0)) # ggg
        print(sys.function(2)) # gg
    }
<bytecode: 0x55c130087190>
<environment: 0x55c1301aa370>
function (file, local = FALSE, echo = verbose, print.eval = echo, 
    exprs, spaced = use_file, verbose = getOption("verbose"), 
    prompt.echo = getOption("prompt"), max.deparse.length = 150, 
    width.cutoff = 60L, deparseCtrl = "showAttributes", chdir = FALSE, 
    encoding = getOption("encoding"), continue.echo = getOption("continue"), 
    skip.echo = 0, keep.source = getOption("keep.source")) 
{
    envir <- if (isTRUE(local)) 
        parent.frame()
    else if (isFALSE(local)) 
        .GlobalEnv
    else if (is.environment(local)) 
        local
    else stop("'local' must be TRUE, FALSE or an environment")
    if (!missing(echo)) {
        if (!is.logical(echo)) 
            stop("'echo' must be logical")
        if (!echo && verbose) {
            warning("'verbose' is TRUE, 'echo' not; ... coercing 'echo <- TRUE'")
            echo <- TRUE
        }
    }
    if (verbose) {
        cat("'envir' chosen:")
        print(envir)
    }
    if (use_file <- missing(exprs)) {
        ofile <- file
        from_file <- FALSE
        srcfile <- NULL
        if (is.character(file)) {
            have_encoding <- !missing(encoding) && encoding != 
                "unknown"
            if (identical(encoding, "unknown")) {
                enc <- utils::localeToCharset()
                encoding <- enc[length(enc)]
            }
            else enc <- encoding
            if (length(enc) > 1L) {
                encoding <- NA
                owarn <- options(warn = 2)
                for (e in enc) {
                  if (is.na(e)) 
                    next
                  zz <- file(file, encoding = e)
                  res <- tryCatch(readLines(zz, warn = FALSE), 
                    error = identity)
                  close(zz)
                  if (!inherits(res, "error")) {
                    encoding <- e
                    break
                  }
                }
                options(owarn)
            }
            if (is.na(encoding)) 
                stop("unable to find a plausible encoding")
            if (verbose) 
                cat(gettextf("encoding = \"%s\" chosen", encoding), 
                  "\n", sep = "")
            if (file == "") {
                file <- stdin()
                srcfile <- "<stdin>"
            }
            else {
                filename <- file
                file <- file(filename, "r", encoding = encoding)
                on.exit(close(file))
                if (isTRUE(keep.source)) {
                  lines <- readLines(file, warn = FALSE)
                  on.exit()
                  close(file)
                  srcfile <- srcfilecopy(filename, lines, file.mtime(filename)[1], 
                    isFile = TRUE)
                }
                else {
                  from_file <- TRUE
                  srcfile <- filename
                }
                loc <- utils::localeToCharset()[1L]
                encoding <- if (have_encoding) 
                  switch(loc, `UTF-8` = "UTF-8", `ISO8859-1` = "latin1", 
                    "unknown")
                else "unknown"
            }
        }
        else {
            lines <- readLines(file, warn = FALSE)
            srcfile <- if (isTRUE(keep.source)) 
                srcfilecopy(deparse(substitute(file)), lines)
            else deparse(substitute(file))
        }
        exprs <- if (!from_file) {
            if (length(lines)) 
                .Internal(parse(stdin(), n = -1, lines, "?", 
                  srcfile, encoding))
            else expression()
        }
        else .Internal(parse(file, n = -1, NULL, "?", srcfile, 
            encoding))
        on.exit()
        if (from_file) 
            close(file)
        if (verbose) 
            cat("--> parsed", length(exprs), "expressions; now eval(.)ing them:\n")
        if (chdir) {
            if (is.character(ofile)) {
                if (grepl("^(ftp|http|file)://", ofile)) 
                  warning("'chdir = TRUE' makes no sense for a URL")
                else if ((path <- dirname(ofile)) != ".") {
                  owd <- getwd()
                  if (is.null(owd)) 
                    stop("cannot 'chdir' as current directory is unknown")
                  on.exit(setwd(owd), add = TRUE)
                  setwd(path)
                }
            }
            else {
                warning("'chdir = TRUE' makes no sense for a connection")
            }
        }
    }
    else {
        if (!missing(file)) 
            stop("specify either 'file' or 'exprs' but not both")
        if (!is.expression(exprs)) 
            exprs <- as.expression(exprs)
    }
    Ne <- length(exprs)
    if (echo) {
        sd <- "\""
        nos <- "[^\"]*"
        oddsd <- paste0("^", nos, sd, "(", nos, sd, nos, sd, 
            ")*", nos, "$")
        trySrcLines <- function(srcfile, showfrom, showto) {
            tryCatch(suppressWarnings(getSrcLines(srcfile, showfrom, 
                showto)), error = function(e) character())
        }
    }
    yy <- NULL
    lastshown <- 0
    srcrefs <- attr(exprs, "srcref")
    if (verbose && !is.null(srcrefs)) {
        cat("has srcrefs:\n")
        utils::str(srcrefs)
    }
    for (i in seq_len(Ne + echo)) {
        tail <- i > Ne
        if (!tail) {
            if (verbose) 
                cat("\n>>>> eval(expression_nr.", i, ")\n\t\t =================\n")
            ei <- exprs[i]
        }
        if (echo) {
            nd <- 0
            srcref <- if (tail) 
                attr(exprs, "wholeSrcref")
            else if (i <= length(srcrefs)) 
                srcrefs[[i]]
            if (!is.null(srcref)) {
                if (i == 1) 
                  lastshown <- min(skip.echo, srcref[3L] - 1)
                if (lastshown < srcref[3L]) {
                  srcfile <- attr(srcref, "srcfile")
                  dep <- trySrcLines(srcfile, lastshown + 1, 
                    srcref[3L])
                  if (length(dep)) {
                    leading <- if (tail) 
                      length(dep)
                    else srcref[1L] - lastshown
                    lastshown <- srcref[3L]
                    while (length(dep) && grepl("^[[:blank:]]*$", 
                      dep[1L])) {
                      dep <- dep[-1L]
                      leading <- leading - 1L
                    }
                    dep <- paste0(rep.int(c(prompt.echo, continue.echo), 
                      c(leading, length(dep) - leading)), dep, 
                      collapse = "\n")
                    nd <- nchar(dep, "c")
                  }
                  else srcref <- NULL
                }
            }
            if (is.null(srcref)) {
                if (!tail) {
                  dep <- substr(paste(deparse(ei, width.cutoff = width.cutoff, 
                    control = deparseCtrl), collapse = "\n"), 
                    12L, 1000000L)
                  dep <- paste0(prompt.echo, gsub("\n", paste0("\n", 
                    continue.echo), dep))
                  nd <- nchar(dep, "c") - 1L
                }
            }
            if (nd) {
                do.trunc <- nd > max.deparse.length
                dep <- substr(dep, 1L, if (do.trunc) 
                  max.deparse.length
                else nd)
                cat(if (spaced) 
                  "\n", dep, if (do.trunc) 
                  paste(if (grepl(sd, dep) && grepl(oddsd, dep)) 
                    " ...\" ..."
                  else " ....", "[TRUNCATED] "), "\n", sep = "")
            }
        }
        if (!tail) {
            yy <- withVisible(eval(ei, envir))
            i.symbol <- mode(ei[[1L]]) == "name"
            if (!i.symbol) {
                curr.fun <- ei[[1L]][[1L]]
                if (verbose) {
                  cat("curr.fun:")
                  utils::str(curr.fun)
                }
            }
            if (verbose >= 2) {
                cat(".... mode(ei[[1L]])=", mode(ei[[1L]]), "; paste(curr.fun)=")
                utils::str(paste(curr.fun))
            }
            if (print.eval && yy$visible) {
                if (isS4(yy$value)) 
                  methods::show(yy$value)
                else print(yy$value)
            }
            if (verbose) 
                cat(" .. after ", sQuote(deparse(ei, control = unique(c(deparseCtrl, 
                  "useSource")))), "\n", sep = "")
        }
    }
    invisible(yy)
}
<bytecode: 0x55c12f07d5c8>
<environment: namespace:base>

sys.pr> t1 <- function() {
sys.pr+   aa <- "here"
sys.pr+   t2 <- function() {
sys.pr+     ## in frame 2 here
sys.pr+     cat("current frame is", sys.nframe(), "\n")
sys.pr+     str(sys.calls()) ## list with two components t1() and t2()
sys.pr+     cat("parents are frame numbers", sys.parents(), "\n") ## 0 1
sys.pr+     print(ls(envir = sys.frame(-1))) ## [1] "aa" "t2"
sys.pr+     invisible()
sys.pr+   }
sys.pr+   t2()
sys.pr+ }

sys.pr> t1()
current frame is 7 
Dotted pair list of 7
 $ : language example(sys.parent, run.donttest = TRUE)
 $ : language source(tf, local, echo = echo, prompt.echo = paste0(prompt.prefix, getOption("prompt")),      continue.echo = pas| __truncated__ ...
 $ : language withVisible(eval(ei, envir))
 $ : language eval(ei, envir)
 $ : language eval(ei, envir)
 $ : language t1()
  ..- attr(*, "srcref")= 'srcref' int [1:8] 40 1 40 4 1 4 40 40
  .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55c12cf7ed88> 
 $ : language t2()
  ..- attr(*, "srcref")= 'srcref' int [1:8] 38 3 38 6 3 6 38 38
  .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55c12cf7ed88> 
parents are frame numbers 0 1 2 2 4 0 6 
[1] "aa" "t2"

sys.pr> test.sys.on.exit <- function() {
sys.pr+   on.exit(print(1))
sys.pr+   ex <- sys.on.exit()
sys.pr+   str(ex)
sys.pr+   cat("exiting...\n")
sys.pr+ }

sys.pr> test.sys.on.exit()
 language print(1)
exiting...
[1] 1

sys.pr> ## gives 'language print(1)', prints 1 on exit
sys.pr> 
sys.pr> ## An example where the parent is not the next frame up the stack
sys.pr> ## since method dispatch uses a frame.
sys.pr> as.double.foo <- function(x)
sys.pr+ {
sys.pr+     str(sys.calls())
sys.pr+     print(sys.frames())
sys.pr+     print(sys.parents())
sys.pr+     print(sys.frame(-1)); print(parent.frame())
sys.pr+     x
sys.pr+ }

sys.pr> t2 <- function(x) as.double(x)

sys.pr> a <- structure(pi, class = "foo")

sys.pr> t2(a)
Dotted pair list of 8
 $ : language example(sys.parent, run.donttest = TRUE)
 $ : language source(tf, local, echo = echo, prompt.echo = paste0(prompt.prefix, getOption("prompt")),      continue.echo = pas| __truncated__ ...
 $ : language withVisible(eval(ei, envir))
 $ : language eval(ei, envir)
 $ : language eval(ei, envir)
 $ : language t2(a)
  ..- attr(*, "srcref")= 'srcref' int [1:8] 63 1 63 5 1 5 63 63
  .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55c12cf7ed88> 
 $ : language as.double(x)
  ..- attr(*, "srcref")= 'srcref' int [1:8] 61 7 61 30 7 30 61 61
  .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55c12cf7ed88> 
 $ : language as.double.foo(x)
  ..- attr(*, "srcref")= 'srcref' int [1:8] 61 7 61 30 7 30 61 61
  .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55c12cf7ed88> 
[[1]]
<environment: 0x55c12cb8ffd0>

[[2]]
<environment: 0x55c12e483248>

[[3]]
<environment: 0x55c1303b2ff8>

[[4]]
<environment: 0x55c1303b2e38>

[[5]]
<environment: R_GlobalEnv>

[[6]]
<environment: 0x55c1303b2b98>

[[7]]
<environment: 0x55c1303b2a10>

[[8]]
<environment: 0x55c1303b27e0>

[1] 0 1 2 2 4 0 6 6
<environment: 0x55c1303b2a10>
<environment: 0x55c1303b2b98>
[1] 3.141593
attr(,"class")
[1] "foo"

sys.pr> ## End(No test)
sys.pr> 
sys.pr> 
> example(system.time, run.donttest = TRUE)

systm.> require(stats)

systm.> ## No test: 
systm.> system.time(for(i in 1:100) mad(runif(1000)))
   user  system elapsed 
  0.028   0.002   0.031 

systm.> ## End(No test)
systm.> ## Not run: 
systm.> ##D exT <- function(n = 10000) {
systm.> ##D   # Purpose: Test if system.time works ok;   n: loop size
systm.> ##D   system.time(for(i in 1:n) x <- mean(rt(1000, df = 4)))
systm.> ##D }
systm.> ##D #-- Try to interrupt one of the following (using Ctrl-C / Escape):
systm.> ##D exT()                 #- about 4 secs on a 2.5GHz Xeon
systm.> ##D system.time(exT())    #~ +/- same
systm.> ## End(Not run)
systm.> 
systm.> 
> example(tempfile, run.donttest = TRUE)

tempfl> ## No test: 
tempfl> tempfile(c("ab", "a b c"))   # give file name with spaces in!
[1] "/tmp/RtmpFY47TA/ab34221c7db7a8"    "/tmp/RtmpFY47TA/a b c342270a269d4"

tempfl> tempfile("plot", fileext = c(".ps", ".pdf"))
[1] "/tmp/RtmpFY47TA/plot3422a267778.ps"  
[2] "/tmp/RtmpFY47TA/plot342242c6543e.pdf"

tempfl> tempdir() # works on all platforms with a platform-dependent result
[1] "/tmp/RtmpFY47TA"

tempfl> ## End(No test)
tempfl> 
tempfl> ## Show how 'check' is working on some platforms:
tempfl> if(exists("I'm brave") && `I'm brave` &&
tempfl+    identical(.Platform$OS.type, "unix") && grepl("^/tmp/", tempdir())) {
tempfl+   cat("Current tempdir(): ", tempdir(), "\n")
tempfl+   cat("Removing it :", file.remove(tempdir()),
tempfl+       "; dir.exists(tempdir()):", dir.exists(tempdir()), "\n")
tempfl+   cat("and now  tempdir(check = TRUE) :", tempdir(check = TRUE),"\n")
tempfl+ }
> example(weekdays, run.donttest = TRUE)

wekdys> ## No test: 
wekdys> weekdays(.leap.seconds)
 [1] "Saturday"  "Monday"    "Tuesday"   "Wednesday" "Thursday"  "Saturday" 
 [7] "Sunday"    "Monday"    "Tuesday"   "Wednesday" "Thursday"  "Friday"   
[13] "Monday"    "Friday"    "Monday"    "Tuesday"   "Wednesday" "Thursday" 
[19] "Friday"    "Monday"    "Tuesday"   "Friday"    "Sunday"    "Thursday" 
[25] "Sunday"    "Wednesday" "Sunday"   

wekdys> months(.leap.seconds)
 [1] "July"    "January" "January" "January" "January" "January" "January"
 [8] "January" "January" "July"    "July"    "July"    "July"    "January"
[15] "January" "January" "July"    "July"    "July"    "January" "July"   
[22] "January" "January" "January" "July"    "July"    "January"

wekdys> quarters(.leap.seconds)
 [1] "Q3" "Q1" "Q1" "Q1" "Q1" "Q1" "Q1" "Q1" "Q1" "Q3" "Q3" "Q3" "Q3" "Q1" "Q1"
[16] "Q1" "Q3" "Q3" "Q3" "Q1" "Q3" "Q1" "Q1" "Q1" "Q3" "Q3" "Q1"

wekdys> ## Julian Day Number (JDN, https://en.wikipedia.org/wiki/Julian_day)
wekdys> ## is the number of days since noon UTC on the first day of 4317 BC.
wekdys> ## in the proleptic Julian calendar.  To more recently, in
wekdys> ## 'Terrestrial Time' which differs from UTC by a few seconds
wekdys> ## See https://en.wikipedia.org/wiki/Terrestrial_Time
wekdys> julian(Sys.Date(), -2440588) # from a day
[1] 2458236
attr(,"origin")
[1] -2440588

wekdys> floor(as.numeric(julian(Sys.time())) + 2440587.5) # from a date-time
[1] 2458235

wekdys> ## End(No test)
wekdys> 
wekdys> 
> library(help = "splines")

		Information on package 'splines'

Description:

Package:            splines
Version:            3.5.0
Priority:           base
Imports:            graphics, stats
Title:              Regression Spline Functions and Classes
Author:             Douglas M. Bates <bates@stat.wisc.edu> and William
                    N. Venables <Bill.Venables@csiro.au>
Maintainer:         R Core Team <R-core@r-project.org>
Description:        Regression spline functions and classes.
License:            Part of R 3.5.0
Suggests:           Matrix, methods
NeedsCompilation:   yes
Built:              R 3.5.0; x86_64-pc-linux-gnu; 2018-04-27 09:25:45
                    UTC; unix

Index:

asVector                Coerce an Object to a Vector
backSpline              Monotone Inverse Spline
bs                      B-Spline Basis for Polynomial Splines
interpSpline            Create an Interpolation Spline
ns                      Generate a Basis Matrix for Natural Cubic
                        Splines
periodicSpline          Create a Periodic Interpolation Spline
polySpline              Piecewise Polynomial Spline Representation
predict.bSpline         Evaluate a Spline at New Values of x
predict.bs              Evaluate a Spline Basis
splineDesign            Design Matrix for B-splines
splineKnots             Knot Vector from a Spline
splineOrder             Determine the Order of a Spline
splines-package         Regression Spline Functions and Classes
xyVector                Construct an 'xyVector' Object

> 
> ## for example(NA)
> if(require("microbenchmark")) {
+   x <- c(NaN, 1:10000)
+   print(microbenchmark(any(is.na(x)), anyNA(x)))
+ } else { ## much less accurate
+   x <- c(NaN, 1e6)
+   nSim <- 2^13
+   print(rbind(is.na = system.time(replicate(nSim, any(is.na(x)))),
+               anyNA = system.time(replicate(nSim, anyNA(x)))))
+ }
Loading required package: microbenchmark
      user.self sys.self elapsed user.child sys.child
is.na     0.012        0   0.012          0         0
anyNA     0.009        0   0.009          0         0
Warning message:
In library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called 'microbenchmark'
> 
> ## utils
> example(news, run.donttest = TRUE)

news> ## Build a db of all R news entries.
news> db <- news()

news> ## Don't show: 
news>   vv <- capture.output(print(db, doBrowse=FALSE))  # without an error

news>   stopifnot(is.character(vv), length(vv) >= 3) # was wrong (for weeks during devel.)

news> ## End(Don't show)
news> ## Bug fixes with PR number in 3.0.1.
news> db3 <- news(Version == "3.0.1" & grepl("^BUG", Category) & grepl("PR#", Text),
news+             db = db)

news> ## Don't show: 
news> stopifnot( !any(attr(db3,"bad")) && nrow(db3) == 12 )

news> ## End(Don't show)
news> 
news> ## News from a date range ('Matrix' is there in a regular R installation):
news> if(length(iM <- find.package("Matrix", quiet=TRUE)) && nzchar(iM)) {
news+    dM <- news(package="Matrix")
news+    stopifnot(identical(dM, news(db=dM)))
news+    dM2014 <- news("2014-01-01" <= Date & Date <= "2014-12-31", db = dM)
news+    stopifnot(paste0("1.1-", 2:4) %in% dM2014[,"Version"])
news+ }

news> ## No test: 
news> ## Which categories have been in use? % R-core maybe should standardize a bit more
news> sort(table(db[, "Category"]), decreasing = TRUE)

                         BUG FIXES                       NEW FEATURES 
                               615                                577 
                         UTILITIES             DEPRECATED AND DEFUNCT 
                                78                                 68 
INSTALLATION and INCLUDED SOFTWARE                 C-LEVEL FACILITIES 
                                55                                 53 
              PACKAGE INSTALLATION       INSTALLATION on a UNIX-ALIKE 
                                30                                 21 
  SIGNIFICANT USER-VISIBLE CHANGES                       LONG VECTORS 
                                16                                 13 
                      INSTALLATION           PERFORMANCE IMPROVEMENTS 
                                10                                  7 
                         DEBUGGING               INTERNATIONALIZATION 
                                 5                                  5 
             WINDOWS BUILD CHANGES                     CODE MIGRATION 
                                 4                                  3 
                  PACKAGE parallel                  INCLUDED SOFTWARE 
                                 3                                  2 
                     DOCUMENTATION 
                                 1 

news> ## Entries with version >= 3.0.0 (including "3.0.0 patched"):
news> table(news(Version >= "3.0.0", db = db)$Version)

3.0.0 3.0.1 3.0.2 3.0.3 3.1.0 3.1.1 3.1.2 3.1.3 3.2.0 3.2.1 3.2.2 3.2.3 3.2.4 
  219    36   118    70   130    58    51    50   116    30    27    47    40 
3.2.5 3.3.0 3.3.1 3.3.2 3.3.3 3.4.0 3.4.1 3.4.2 3.4.3 3.4.4 3.5.0 
    1   121    11    41    22   166    14    33     9    15   141 

news> ## End(No test)
news> 
news> 
> example(sessionInfo, run.donttest = TRUE)

sssnIn> ## No test: 
sssnIn> sessionInfo()
R version 3.5.0 (2018-04-23)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Arch Linux

Matrix products: default
BLAS: /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/lib/libRblas.so
LAPACK: /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/lib/libRlapack.so

locale:
[1] C

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

loaded via a namespace (and not attached):
[1] compiler_3.5.0 tools_3.5.0   

sssnIn> toLatex(sessionInfo(), locale = FALSE)
\begin{itemize}\raggedright
  \item R version 3.5.0 (2018-04-23), \verb|x86_64-pc-linux-gnu|
  \item Running under: \verb|Arch Linux|
  \item Matrix products: default
  \item BLAS: \verb|/home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/lib/libRblas.so|
  \item LAPACK: \verb|/home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/lib/libRlapack.so|
  \item Base packages: base, datasets, grDevices, graphics, methods,
    stats, utils
  \item Loaded via a namespace (and not attached): compiler~3.5.0,
    tools~3.5.0
\end{itemize}

sssnIn> ## End(No test)
sssnIn> 
sssnIn> 
> 
> ## datasets
> example(JohnsonJohnson, run.donttest = TRUE)

JhnsnJ> ## No test: 
JhnsnJ> require(stats); require(graphics)

JhnsnJ> JJ <- log10(JohnsonJohnson)

JhnsnJ> plot(JJ)

JhnsnJ> ## This example gives a possible-non-convergence warning on some
JhnsnJ> ## platforms, but does seem to converge on x86 Linux and Windows.
JhnsnJ> (fit <- StructTS(JJ, type = "BSM"))

Call:
StructTS(x = JJ, type = "BSM")

Variances:
    level      slope       seas    epsilon  
1.948e-04  6.548e-06  4.138e-04  2.647e-04  

JhnsnJ> tsdiag(fit)

JhnsnJ> sm <- tsSmooth(fit)

JhnsnJ> plot(cbind(JJ, sm[, 1], sm[, 3]-0.5), plot.type = "single",
JhnsnJ+      col = c("black", "green", "blue"))

JhnsnJ> abline(h = -0.5, col = "grey60")

JhnsnJ> monthplot(fit)

JhnsnJ> ## End(No test)
JhnsnJ> 
JhnsnJ> 
> example(ability.cov, run.donttest = TRUE)

ablty.> ## No test: 
ablty.> require(stats)

ablty.> (ability.FA <- factanal(factors = 1, covmat = ability.cov))

Call:
factanal(factors = 1, covmat = ability.cov)

Uniquenesses:
general picture  blocks    maze reading   vocab 
  0.535   0.853   0.748   0.910   0.232   0.280 

Loadings:
        Factor1
general 0.682  
picture 0.384  
blocks  0.502  
maze    0.300  
reading 0.877  
vocab   0.849  

               Factor1
SS loadings      2.443
Proportion Var   0.407

Test of the hypothesis that 1 factor is sufficient.
The chi square statistic is 75.18 on 9 degrees of freedom.
The p-value is 1.46e-12 

ablty.> update(ability.FA, factors = 2)

Call:
factanal(factors = 2, covmat = ability.cov)

Uniquenesses:
general picture  blocks    maze reading   vocab 
  0.455   0.589   0.218   0.769   0.052   0.334 

Loadings:
        Factor1 Factor2
general 0.499   0.543  
picture 0.156   0.622  
blocks  0.206   0.860  
maze    0.109   0.468  
reading 0.956   0.182  
vocab   0.785   0.225  

               Factor1 Factor2
SS loadings      1.858   1.724
Proportion Var   0.310   0.287
Cumulative Var   0.310   0.597

Test of the hypothesis that 2 factors are sufficient.
The chi square statistic is 6.11 on 4 degrees of freedom.
The p-value is 0.191 

ablty.> ## The signs of factors and hence the signs of correlations are
ablty.> ## arbitrary with promax rotation.
ablty.> update(ability.FA, factors = 2, rotation = "promax")

Call:
factanal(factors = 2, covmat = ability.cov, rotation = "promax")

Uniquenesses:
general picture  blocks    maze reading   vocab 
  0.455   0.589   0.218   0.769   0.052   0.334 

Loadings:
        Factor1 Factor2
general  0.364   0.470 
picture          0.671 
blocks           0.932 
maze             0.508 
reading  1.023         
vocab    0.811         

               Factor1 Factor2
SS loadings      1.853   1.807
Proportion Var   0.309   0.301
Cumulative Var   0.309   0.610

Factor Correlations:
        Factor1 Factor2
Factor1   1.000   0.557
Factor2   0.557   1.000

Test of the hypothesis that 2 factors are sufficient.
The chi square statistic is 6.11 on 4 degrees of freedom.
The p-value is 0.191 

ablty.> ## End(No test)
ablty.> 
ablty.> 
> example(npk, run.donttest = TRUE)

npk> ## No test: 
npk> options(contrasts = c("contr.sum", "contr.poly"))

npk> npk.aov <- aov(yield ~ block + N*P*K, npk)

npk> npk.aov
Call:
   aov(formula = yield ~ block + N * P * K, data = npk)

Terms:
                   block        N        P        K      N:P      N:K      P:K
Sum of Squares  343.2950 189.2817   8.4017  95.2017  21.2817  33.1350   0.4817
Deg. of Freedom        5        1        1        1        1        1        1
                Residuals
Sum of Squares   185.2867
Deg. of Freedom        12

Residual standard error: 3.929447
1 out of 13 effects not estimable
Estimated effects may be unbalanced

npk> summary(npk.aov)
            Df Sum Sq Mean Sq F value  Pr(>F)   
block        5  343.3   68.66   4.447 0.01594 * 
N            1  189.3  189.28  12.259 0.00437 **
P            1    8.4    8.40   0.544 0.47490   
K            1   95.2   95.20   6.166 0.02880 * 
N:P          1   21.3   21.28   1.378 0.26317   
N:K          1   33.1   33.14   2.146 0.16865   
P:K          1    0.5    0.48   0.031 0.86275   
Residuals   12  185.3   15.44                   
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

npk> coef(npk.aov)
(Intercept)      block1      block2      block3      block4      block5 
 54.8750000  -0.8500000   2.5750000   5.9000000  -4.7500000  -4.3500000 
         N1          P1          K1       N1:P1       N1:K1       P1:K1 
 -2.8083333   0.5916667   1.9916667  -0.9416667  -1.1750000   0.1416667 

npk> options(contrasts = c("contr.treatment", "contr.poly"))

npk> npk.aov1 <- aov(yield ~ block + N + K, data = npk)

npk> summary.lm(npk.aov1)

Call:
aov(formula = yield ~ block + N + K, data = npk)

Residuals:
    Min      1Q  Median      3Q     Max 
-6.4083 -2.1438  0.2042  2.3292  7.0750 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)   53.208      2.276  23.381  8.5e-14 ***
block2         3.425      2.787   1.229  0.23690    
block3         6.750      2.787   2.422  0.02769 *  
block4        -3.900      2.787  -1.399  0.18082    
block5        -3.500      2.787  -1.256  0.22723    
block6         2.325      2.787   0.834  0.41646    
N1             5.617      1.609   3.490  0.00302 ** 
K1            -3.983      1.609  -2.475  0.02487 *  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 3.942 on 16 degrees of freedom
Multiple R-squared:  0.7163,	Adjusted R-squared:  0.5922 
F-statistic: 5.772 on 7 and 16 DF,  p-value: 0.001805


npk> se.contrast(npk.aov1, list(N=="0", N=="1"), data = npk)
[1] 1.609175

npk> model.tables(npk.aov1, type = "means", se = TRUE)
Tables of means
Grand mean
       
54.875 

 block 
block
    1     2     3     4     5     6 
54.03 57.45 60.77 50.12 50.52 56.35 

 N 
N
    0     1 
52.07 57.68 

 K 
K
    0     1 
56.87 52.88 

Standard errors for differences of means
        block     N     K
        2.787 1.609 1.609
replic.     4    12    12

npk> ## End(No test)
npk> 
npk> 
> 
> ## grDevices
> example(grSoftVersion, run.donttest = TRUE)

grSftV> ## No test: 
grSftV> grSoftVersion()
                   cairo                   libpng                     jpeg 
               "1.15.10"                 "1.6.34"                    "8.0" 
                 libtiff 
"LIBTIFF, Version 4.0.9" 

grSftV> ## End(No test)
grSftV> 
grSftV> 
grSftV> 
> if(.Platform$OS.type == "windows") {
+     example(windowsFonts, run.donttest = TRUE)
+ } else {
+     example(X11Fonts, run.donttest = TRUE)
+     example(quartzFonts, run.donttest = TRUE)
+ }

X11Fnt> X11Fonts()
$serif
[1] "-*-times-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$sans
[1] "-*-helvetica-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$mono
[1] "-*-courier-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$Times
[1] "-adobe-times-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$Helvetica
[1] "-adobe-helvetica-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$CyrTimes
[1] "-cronyx-times-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$CyrHelvetica
[1] "-cronyx-helvetica-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$Arial
[1] "-monotype-arial-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$Mincho
[1] "-*-mincho-%s-%s-*-*-%d-*-*-*-*-*-*-*"


X11Fnt> X11Fonts("mono")
$mono
[1] "-*-courier-%s-%s-*-*-%d-*-*-*-*-*-*-*"


X11Fnt> utopia <- X11Font("-*-utopia-*-*-*-*-*-*-*-*-*-*-*-*")

X11Fnt> X11Fonts(utopia = utopia)

qrtzFn> quartzFonts()
$serif
[1] "Times-Roman"      "Times-Bold"       "Times-Italic"     "Times-BoldItalic"

$sans
[1] "Helvetica"             "Helvetica-Bold"        "Helvetica-Oblique"    
[4] "Helvetica-BoldOblique"

$mono
[1] "Courier"             "Courier-Bold"        "Courier-Oblique"    
[4] "Courier-BoldOblique"


qrtzFn> quartzFonts("mono")
$mono
[1] "Courier"             "Courier-Bold"        "Courier-Oblique"    
[4] "Courier-BoldOblique"


qrtzFn> ## Not run: 
qrtzFn> ##D ## for East Asian locales you can use something like
qrtzFn> ##D quartzFonts(sans = quartzFont(rep("AppleGothic", 4)),
qrtzFn> ##D             serif = quartzFont(rep("AppleMyungjp", 4)))
qrtzFn> ##D ## since the default fonts may well not have the glyphs needed
qrtzFn> ## End(Not run)
qrtzFn> 
qrtzFn> 
> 
> library(tools)
> example(Rdutils, run.donttest = TRUE)
Warning message:
In example(Rdutils, run.donttest = TRUE) : no help found for 'Rdutils'
> example(fileutils, run.donttest = TRUE)
Warning message:
In example(fileutils, run.donttest = TRUE) : no help found for 'fileutils'
> example(makevars_user, run.donttest = TRUE)

mkvrs_> ## No test: 
mkvrs_> makevars_user()
character(0)

mkvrs_> makevars_site()
character(0)

mkvrs_> ## End(No test)
mkvrs_> ## Don't show: 
mkvrs_> checkMV <- function(r)
mkvrs_+   stopifnot(is.character(r),
mkvrs_+             length(r) == 0 || (length(r) == 1 && file.exists(r)))

mkvrs_> checkMV(makevars_user())

mkvrs_> checkMV(makevars_site())

mkvrs_> ## End(Don't show)
mkvrs_> 
mkvrs_> 
mkvrs_> 
> ## results are location- and OS-specific
> example(parseLatex, run.donttest = TRUE) # charset-specific

prsLtx> ## No test: 
prsLtx> latex <- parseLatex("fa\\c{c}ile")

prsLtx> deparseLatex(latexToUtf8(latex))
[1] "fa<U+00E7>ile"

prsLtx> ## End(No test)
prsLtx> 
prsLtx> 
> example(loadRdMacros, run.donttest = TRUE) # collation-specific

ldRdMc> ## No test: 
ldRdMc> f <- tempfile()

ldRdMc> writeLines(paste0("\\newcommand{\\logo}{\\if{html}{\\figure{Rlogo.svg}{options: width=100}",
ldRdMc+                   "\\if{latex}{\\figure{Rlogo.pdf}{options: width=0.5in}}}"),
ldRdMc+ 	    f)

ldRdMc> m <- loadRdMacros(f)

ldRdMc> ls(m)
[1] "\\logo"

ldRdMc> ls(parent.env(m))
 [1] "#endif"         "#ifdef"         "#ifndef"        "\\R"           
 [5] "\\RdOpts"       "\\Rdversion"    "\\S3method"     "\\S4method"    
 [9] "\\Sexpr"        "\\acronym"      "\\alias"        "\\arguments"   
[13] "\\author"       "\\bold"         "\\cite"         "\\code"        
[17] "\\command"      "\\concept"      "\\cr"           "\\dQuote"      
[21] "\\deqn"         "\\describe"     "\\description"  "\\details"     
[25] "\\dfn"          "\\docType"      "\\dontrun"      "\\dontshow"    
[29] "\\donttest"     "\\dots"         "\\email"        "\\emph"        
[33] "\\enc"          "\\encoding"     "\\enumerate"    "\\env"         
[37] "\\eqn"          "\\examples"     "\\figure"       "\\file"        
[41] "\\format"       "\\href"         "\\if"           "\\ifelse"      
[45] "\\item"         "\\itemize"      "\\kbd"          "\\keyword"     
[49] "\\ldots"        "\\link"         "\\linkS4class"  "\\method"      
[53] "\\name"         "\\newcommand"   "\\note"         "\\option"      
[57] "\\out"          "\\pkg"          "\\preformatted" "\\references"  
[61] "\\renewcommand" "\\sQuote"       "\\samp"         "\\section"     
[65] "\\seealso"      "\\source"       "\\special"      "\\strong"      
[69] "\\subsection"   "\\synopsis"     "\\tab"          "\\tabular"     
[73] "\\testonly"     "\\title"        "\\url"          "\\usage"       
[77] "\\value"        "\\var"          "\\verb"        

ldRdMc> ls(parent.env(parent.env(m)))
character(0)

ldRdMc> ## End(No test)
ldRdMc> 
ldRdMc> 
ldRdMc> 
Warning message:
/tmp/RtmpFY47TA/file34224ad24210:2: unexpected END_OF_INPUT '\if{html}{\figure{Rlogo.svg}{options: width=100}\if{latex}{\figure{Rlogo.pdf}{options: width=0.5in}}}
' 
> 
> ## part of example(buildVignettes) at one time
> gVigns <- pkgVignettes("grid")
> str(gVigns) # contains paths
List of 8
 $ docs     : chr [1:13] "/home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/library/grid/doc/displaylist.Rnw" "/home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/library/grid/doc/frame.Rnw" "/home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/library/grid/doc/grid.Rnw" "/home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/library/grid/doc/grobs.Rnw" ...
 $ names    : chr [1:13] "displaylist" "frame" "grid" "grobs" ...
 $ engines  : chr [1:13] "utils::Sweave" "utils::Sweave" "utils::Sweave" "utils::Sweave" ...
 $ patterns : chr [1:13] "[.][rRsS](nw|tex)$" "[.][rRsS](nw|tex)$" "[.][rRsS](nw|tex)$" "[.][rRsS](nw|tex)$" ...
 $ encodings: Named chr [1:13] "" "" "" "" ...
  ..- attr(*, "names")= chr [1:13] "/home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/library/grid/doc/displaylist.Rnw" "/home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/library/grid/doc/frame.Rnw" "/home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/library/grid/doc/grid.Rnw" "/home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/library/grid/doc/grobs.Rnw" ...
 $ dir      : chr "/home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/library/grid/doc"
 $ pkgdir   : chr "/home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/library/grid"
 $ msg      : chr(0) 
 - attr(*, "class")= chr "pkgVignettes"
> 
> vind <- system.file(package = "grid", "doc", "index.html")
> if(nzchar(vind)) { # so vignettes have been installed
+     `%=f=%` <- function(a, b) normalizePath(a) == normalizePath(b)
+     with(gVigns,
+          stopifnot(engines == "utils::Sweave",
+                    pkgdir %=f=% system.file(package="grid"),
+                    dir    %=f=% system.file(package = "grid", "doc"),
+                    (n. <- length(docs)) >= 12, # have 13
+                    n. == length(names), n. == length(engines),
+                    length(msg) == 0) ) # as it is a 'base' package
+     stopifnot("grid" %in% gVigns$names, inherits(gVigns, "pkgVignettes"))
+ }
> 
> ## This might leave collation changed, so do not put other things after it.
> example(icuSetCollate, run.donttest = TRUE)

icStCl> ## No test: 
icStCl> ## These examples depend on having ICU available, and on the locale.
icStCl> ## As we don't know the current settings, we can only reset to the default.
icStCl> if(capabilities("ICU")) {
icStCl+     print(icuGetCollate())
icStCl+     print(icuGetCollate("valid"))
icStCl+     x <- c("Aarhus", "aarhus", "safe", "test", "Zoo")
icStCl+     print(sort(x))
icStCl+     icuSetCollate(case_first = "upper"); print(sort(x))
icStCl+     icuSetCollate(case_first = "lower"); print(sort(x))
icStCl+ 
icStCl+     ## Danish collates upper-case-first and with 'aa' as a single letter
icStCl+     icuSetCollate(locale = "da_DK", case_first = "default"); print(sort(x)) 
icStCl+     ## Estonian collates Z between S and T
icStCl+     icuSetCollate(locale = "et_EE"); print(sort(x))
icStCl+     icuSetCollate(locale = "default"); print(icuGetCollate("valid"))
icStCl+ }
[1] "ICU not in use"
[1] "ICU not in use"
[1] "Aarhus" "Zoo"    "aarhus" "safe"   "test"  
[1] "Aarhus" "Zoo"    "aarhus" "safe"   "test"  
[1] "Aarhus" "Zoo"    "aarhus" "safe"   "test"  
[1] "safe"   "test"   "Zoo"    "Aarhus" "aarhus"
[1] "aarhus" "Aarhus" "safe"   "Zoo"    "test"  
[1] "root"

icStCl> ## End(No test)
icStCl> 
icStCl> 
> proc.time()
   user  system elapsed 
  4.845   0.199   8.927 
> 
