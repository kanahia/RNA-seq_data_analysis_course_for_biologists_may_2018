
R version 3.5.0 (2018-04-23) -- "Joy in Playing"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ## PR 1271  detach("package:base") crashes R.
> tools::assertError(detach("package:base"))
> 
> 
> ## invalid 'lib.loc'
> stopifnot(length(installed.packages("mgcv")) == 0)
> ## gave a low-level error message
> 
> 
> ## package.skeleton() with metadata-only code
> ## work in current (= ./tests/ directory):
> tmp <- tempfile()
> writeLines(c('setClass("foo", contains="numeric")',
+              'setMethod("show", "foo",',
+              '          function(object) cat("I am a \\"foo\\"\\n"))'),
+            tmp)
> if(file.exists("myTst")) unlink("myTst", recursive=TRUE)
> package.skeleton("myTst", code_files = tmp)# with a file name warning
Creating directories ...
Creating DESCRIPTION ...
Creating NAMESPACE ...
Creating Read-and-delete-me ...
Copying code files ...
Making help files ...
Done.
Further steps are described in './myTst/Read-and-delete-me'.
Warning message:
In package.skeleton("myTst", code_files = tmp) :
  Invalid file name(s) for R code in ./myTst/R:
  'file34461775049c'
 are now renamed to 'z<name>.R'
> file.copy(tmp, (tm2 <- paste(tmp,".R", sep="")))
[1] TRUE
> unlink("myTst", recursive=TRUE)
> op <- options(warn=2) # *NO* "invalid file name" warning {failed in 2.7.[01]}:
> package.skeleton("myTst", code_files = tm2)
Creating directories ...
Creating DESCRIPTION ...
Creating NAMESPACE ...
Creating Read-and-delete-me ...
Copying code files ...
Making help files ...
Done.
Further steps are described in './myTst/Read-and-delete-me'.
> options(op)
> ##_2_ only a class, no generics/methods:
> writeLines(c('setClass("DocLink",',
+              'representation(name="character",',
+              '               desc="character"))'), tmp)
> if(file.exists("myTst2")) unlink("myTst2", recursive=TRUE)
> package.skeleton("myTst2", code_files = tmp)
Creating directories ...
Creating DESCRIPTION ...
Creating NAMESPACE ...
Creating Read-and-delete-me ...
Copying code files ...
Making help files ...
Done.
Further steps are described in './myTst2/Read-and-delete-me'.
Warning message:
In package.skeleton("myTst2", code_files = tmp) :
  Invalid file name(s) for R code in ./myTst2/R:
  'file34461775049c'
 are now renamed to 'z<name>.R'
> ##- end_2_ # failed in R 2.11.0
> stopifnot(1 == grep("setClass",
+ 	  readLines(list.files("myTst/R", full.names=TRUE))),
+ 	  c("foo-class.Rd","show-methods.Rd") %in% list.files("myTst/man"))
> ## failed for several reasons in R < 2.7.0
> ##
> ## Part 2: -- build, install, load and "inspect" the package:
> build.pkg <- function(dir) {
+     stopifnot(dir.exists(dir))
+     patt <- paste(basename(dir), ".*tar\\.gz$", sep="_")
+     unlink(dir('.', pattern = patt))
+     Rcmd <- paste(shQuote(file.path(R.home("bin"), "R")), "CMD")
+     r <- tail(system(paste(Rcmd, "build --keep-empty-dirs", shQuote(dir)),
+                      intern = TRUE), 3)
+     ## return name of tar file built
+     structure(dir('.', pattern = patt), log3 = r)
+ }
> build.pkg("myTst")

[1] "myTst_1.0.tar.gz"
attr(,"log3")
[1] "* checking for LF line-endings in source and make files and shell scripts"
[2] "* checking for empty or unneeded directories"                             
[3] "* building 'myTst_1.0.tar.gz'"                                            
> ## clean up any previous attempt (which might have left a 00LOCK)
> unlink("myLib", recursive = TRUE)
> dir.create("myLib")
> install.packages("myTst", lib = "myLib", repos=NULL, type = "source") # with warnings
* installing *source* package 'myTst' ...
** R
** byte-compile and prepare package for lazy loading
** help
Warning: /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/tests/myTst/man/myTst-package.Rd:27: All text must be in a section
Warning: /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/tests/myTst/man/myTst-package.Rd:28: All text must be in a section
*** installing help indices
** building package indices
** testing if installed package can be loaded
* DONE (myTst)
> print(installed.packages(lib.loc= "myLib", priority= "NA"))## (PR#13332)
      Package LibPath Version Priority Depends   Imports LinkingTo Suggests
myTst "myTst" "myLib" "1.0"   NA       "methods" NA      NA        NA      
      Enhances License                     License_is_FOSS
myTst NA       "What license is it under?" NA             
      License_restricts_use OS_type MD5sum NeedsCompilation Built  
myTst NA                    NA      NA     NA               "3.5.0"
> stopifnot(require("myTst",lib = "myLib"))
Loading required package: myTst
> sm <- findMethods(show, where= as.environment("package:myTst"))
> stopifnot(names(sm@names) == "foo")
> unlink("myTst_*")
> 
> ## getPackageName()  for "package:foo":
> require('methods')
> library(tools)
> oo <- options(warn=2)
> detach("package:tools", unload=TRUE)
> options(oo)
> ## gave warning (-> Error) about creating package name
> 
> 
> ## More building & installing packages
> ## NB: tests were added here for 2.11.0.
> ## NB^2: do not do this in the R sources (but in a build != src directory!)
> ## and this testdir is not installed.
> if(interactive() && Sys.getenv("USER") == "maechler")
+     Sys.setenv(SRCDIR = normalizePath("~/R/D/r-devel/R/tests"))
> (pkgSrcPath <- file.path(Sys.getenv("SRCDIR"), "Pkgs"))# e.g., -> "../../R/tests/Pkgs"
[1] "./Pkgs"
> if(!file_test("-d", pkgSrcPath) && !interactive()) {
+     unlink("myTst", recursive=TRUE)
+     print(proc.time())
+     q("no")
+ }
> ## else w/o clause:
> 
> do.cleanup <- !nzchar(Sys.getenv("R_TESTS_NO_CLEAN"))
> has.symlink <- (.Platform$OS.type != "windows")
> ## Installing "on to" a package existing as symlink in the lib.loc
> ## -- used to fail with misleading error message (#PR 16725):
> if(has.symlink && dir.create("myLib_2") &&
+    file.rename("myLib/myTst", "myLib_2/myTst") &&
+    file.symlink("../myLib_2/myTst", "myLib/myTst"))
+     install.packages("myTst", lib = "myLib", repos=NULL, type = "source")
* installing *source* package 'myTst' ...
** R
** byte-compile and prepare package for lazy loading
** help
Warning: /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/tests/myTst/man/myTst-package.Rd:27: All text must be in a section
Warning: /home/mmigdal/Documents/phd/rna_seq_workshop_2018/.local/R-3.5.0/tests/myTst/man/myTst-package.Rd:28: All text must be in a section
*** installing help indices
** building package indices
** testing if installed package can be loaded
* DONE (myTst)
> ## In R <= 3.3.2 gave error with *misleading* error message:
> ## ERROR: ‘myTst’ is not a legal package name
> 
> 
> ## file.copy(pkgSrcPath, tempdir(), recursive = TRUE) - not ok: replaces symlink by copy
> system(paste('cp -R', shQuote(pkgSrcPath), shQuote(tempdir())))
> pkgPath <- file.path(tempdir(), "Pkgs")
> ## pkgB tests an empty R directory
> dir.create(file.path(pkgPath, "pkgB", "R"), recursive = TRUE,
+ 	   showWarnings = FALSE)
> p.lis <- if("Matrix" %in% row.names(installed.packages(.Library)))
+ 	     c("pkgA", "pkgB", "exNSS4") else "exNSS4"
> pkgApath <- file.path(pkgPath, "pkgA")
> if("pkgA" %in% p.lis && !dir.exists(d <- pkgApath)) {
+     cat("symlink 'pkgA' does not exist as directory ",d,"; copying it\n", sep='')
+     file.copy(file.path(pkgPath, "xDir", "pkg"), to = d, recursive=TRUE)
+     ## if even the copy failed (NB: pkgB depends on pkgA)
+     if(!dir.exists(d)) p.lis <- p.lis[!(p.lis %in% c("pkgA", "pkgB"))]
+ }
> for(p. in p.lis) {
+     cat("building package", p., "...\n")
+     r <- build.pkg(file.path(pkgPath, p.))
+     cat("installing package", p., "using file", r, "...\n")
+     ## we could install the tar file ... (see build.pkg()'s definition)
+     install.packages(r, lib = "myLib", repos=NULL, type = "source")
+     stopifnot(require(p.,lib = "myLib", character.only=TRUE))
+     detach(pos = match(p., sub("^package:","", search())))
+ }
building package pkgA ...

installing package pkgA using file pkgA_1.2.tar.gz ...
* installing *source* package 'pkgA' ...
** R
** data
*** moving datasets to lazyload DB
** byte-compile and prepare package for lazy loading
** help
*** installing help indices
** building package indices
** testing if installed package can be loaded
* DONE (pkgA)
Loading required package: pkgA

Attaching package: 'pkgA'

The following object is masked from 'package:base':

    search

building package pkgB ...

installing package pkgB using file pkgB_1.0.tar.gz ...
* installing *source* package 'pkgB' ...
** help
No man pages found in package  'pkgB' 
*** installing help indices
** building package indices
** testing if installed package can be loaded
* DONE (pkgB)
Loading required package: pkgB
building package exNSS4 ...

installing package exNSS4 using file exNSS4_1.1.tar.gz ...
* installing *source* package 'exNSS4' ...
** R
** byte-compile and prepare package for lazy loading
** help
No man pages found in package  'exNSS4' 
*** installing help indices
** building package indices
** testing if installed package can be loaded
* DONE (exNSS4)
Loading required package: exNSS4
> (res <- installed.packages(lib.loc = "myLib", priority = "NA"))
       Package  LibPath Version Priority
exNSS4 "exNSS4" "myLib" "1.1"   NA      
myTst  "myTst"  "myLib" "1.0"   NA      
pkgA   "pkgA"   "myLib" "1.2"   NA      
pkgB   "pkgB"   "myLib" "1.0"   NA      
       Depends                                
exNSS4 "methods"                              
myTst  "methods"                              
pkgA   "R (>= 2.14.0), R (>= r56550), methods"
pkgB   NA                                     
       Imports                                 LinkingTo Suggests Enhances
exNSS4 NA                                      NA        NA       NA      
myTst  NA                                      NA        NA       NA      
pkgA   "Matrix (>= 1.2-0), Matrix (<= 99.9-9)" NA        NA       NA      
pkgB   "methods, graphics, pkgA"               NA        NA       NA      
       License                     License_is_FOSS License_restricts_use
exNSS4 "GPL (>= 2)"                NA              NA                   
myTst  "What license is it under?" NA              NA                   
pkgA   "GPL (>= 2)"                NA              NA                   
pkgB   "GPL (>= 2)"                NA              NA                   
       OS_type MD5sum NeedsCompilation Built  
exNSS4 NA      NA     "no"             "3.5.0"
myTst  NA      NA     NA               "3.5.0"
pkgA   NA      NA     "no"             "3.5.0"
pkgB   NA      NA     "no"             "3.5.0"
> stopifnot(identical(res[,"Package"], setNames(,sort(c(p.lis, "myTst")))),
+ 	  res[,"LibPath"] == "myLib")
> ### Specific Tests on our "special" packages: ------------------------------
> 
> ## These used to fail because of the sym.link in pkgA
> if("pkgA" %in% p.lis && dir.exists(pkgApath)) {
+     cat("undoc(pkgA):\n"); print(uA <- tools::undoc(dir = pkgApath))
+     cat("codoc(pkgA):\n"); print(cA <- tools::codoc(dir = pkgApath))
+     stopifnot(identical(uA$`code objects`, c("nil", "search")),
+               identical(uA$`data sets`,    "nilData"))
+ }
undoc(pkgA):
Undocumented code objects:
  'nil' 'search'
Undocumented data sets:
  'nilData'
codoc(pkgA):
Functions or methods with usage in documentation object 'f' but not in code:
  f

> 
> ## - Check conflict message.
> ## - Find objects which are NULL via "::" -- not to be expected often
> ##   we have one in our pkgA, but only if Matrix is present.
> if(dir.exists(file.path("myLib", "pkgA"))) {
+   msgs <- capture.output(require(pkgA, lib="myLib"), type = "message")
+   writeLines(msgs)
+   stopifnot(length(msgs) > 2,
+             length(grep("The following object is masked.*package:base", msgs)) > 0,
+             length(grep("\\bsearch\\b", msgs)) > 0)
+   data(package = "pkgA") # -> nilData
+   stopifnot(is.null( pkgA::  nil),
+ 	    is.null( pkgA::: nil),
+ 	    is.null( pkgA::  nilData)) # <-
+   ## R-devel (pre 3.2.0) wrongly errored for NULL lazy data
+   ## ::: does not apply to data sets:
+   tools::assertError(is.null(pkgA:::nilData))
+ }
Loading required package: pkgA

Attaching package: 'pkgA'

The following object is masked from 'package:base':

    search

> 
> ## Check error from invalid logical field in DESCRIPTION:
> (okA <- dir.exists(pkgApath) &&
+      file.exists(DN <- file.path(pkgApath, "DESCRIPTION")))
[1] TRUE
> if(okA) {
+   Dlns <- readLines(DN); i <- grep("^LazyData:", Dlns)
+   Dlns[i] <- paste0(Dlns[i], ",") ## adding a ","
+   writeLines(Dlns, con = DN)
+   if(interactive()) { ## FIXME!  Why does this fail, e.g., when run via 'make' ?
+     ## install.packages() should give "the correct" error but we cannot catch it
+     ## One level lower is not much better, needing sink() as capture.output() fails
+     ftf <- file(tf <- tempfile("inst_pkg"), open = "wt")
+     sink(ftf); sink(ftf, type = "message")# "message" should be sufficient
+     tools:::.install_packages(c("--clean", "--library=myLib", pkgApath))
+     ##      -----------------                                 ----
+     sink(type="message"); sink()## ; close(ftf); rm(ftf)# end sink()
+     writeLines(paste(" ", msgs <- readLines(tf)))
+     print(err <- grep("^ERROR:", msgs, value=TRUE))
+     stopifnot(length(err) > 0, grepl("invalid .*LazyData .*DESCRIPTION", err))
+   }
+ }
> 
> 
> ## tests here should *NOT* assume recommended packages,
> ## let alone where they are installed
> if(dir.exists(file.path("myLib", "exNSS4")) &&
+    dir.exists(file.path(.Library, "Matrix"))) {
+     for(ns in c(rev(p.lis), "Matrix")) unloadNamespace(ns)
+     ## Both exNSS4 and Matrix define "atomicVector" *the same*,
+     ## but  'exNSS4'  has it extended - and hence *both* are registered in cache -> "conflicts"
+     requireNamespace("exNSS4", lib= "myLib")
+     ## Found in cache, since there is only one definition.
+     ## Might confuse users.
+     stopifnot(isVirtualClass(getClass("atomicVector")))
+     requireNamespace("Matrix", lib= .Library)
+     ## Throws an error, because there is ambiguity in the cache,
+     ## and the dynamic search will not find anything, since the packages
+     ## are not attached.
+     tools::assertCondition(
+         acl <- getClass("atomicVector")
+         )
+     ## Once Matrix is attached, we find a unique definition.
+     library(Matrix)
+     stopifnot(isVirtualClass(getClass("atomicVector")))
+ }
Loading required namespace: exNSS4
Loading required namespace: Matrix
Found more than one class "atomicVector" in cache; using the first, from namespace 'exNSS4'
Also defined by 'Matrix'
Found more than one class "atomicVector" in cache; using the first, from namespace 'exNSS4'
Also defined by 'Matrix'
Found more than one class "atomicVector" in cache; using the first, from namespace 'exNSS4'
Also defined by 'Matrix'
Found more than one class "atomicVector" in cache; using the first, from namespace 'exNSS4'
Also defined by 'Matrix'
> 
> ## clean up
> rmL <- c("myLib", if(has.symlink) "myLib_2", "myTst", file.path(pkgPath))
> if(do.cleanup) {
+     for(nm in rmL) unlink(nm, recursive = TRUE)
+ } else {
+     cat("Not cleaning, i.e., keeping ", paste(rmL, collapse=", "), "\n")
+ }
> 
> proc.time()
   user  system elapsed 
 13.219   1.418  14.735 
> 
